/// 邮件过滤器组件
/// 提供邮件分类、状态、搜索等过滤功能
library;

import 'dart:async';
// Material导入已移除，使用纯Cupertino架构
import 'package:flutter/cupertino.dart';
import 'package:flutter/services.dart';
import '../../../domain/entities/email_filters.dart';

class EmailFiltersWidget extends StatefulWidget {
  final EmailFilters filters;
  final Function(EmailFilters) onFiltersChanged;
  final VoidCallback onClearFilters;

  const EmailFiltersWidget({
    super.key,
    required this.filters,
    required this.onFiltersChanged,
    required this.onClearFilters,
  });

  @override
  State<EmailFiltersWidget> createState() => _EmailFiltersWidgetState();
}

class _EmailFiltersWidgetState extends State<EmailFiltersWidget>
    with SingleTickerProviderStateMixin {
  late TextEditingController _searchController;
  late AnimationController _animationController;
  late Animation<double> _expandAnimation;
  bool _isExpanded = false;
  Timer? _debounceTimer;
  bool _isComposing = false;
  String _lastSearchText = '';

  @override
  void initState() {
    super.initState();
    _searchController = TextEditingController(text: widget.filters.search ?? '');
    _lastSearchText = widget.filters.search ?? ''; // 初始化上次搜索文本
    // 只在清除按钮需要时更新UI，避免输入时频繁刷新
    _searchController.addListener(_onSearchControllerChanged);
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _expandAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _debounceTimer?.cancel();
    _searchController.dispose();
    _animationController.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(EmailFiltersWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.filters.search != widget.filters.search) {
      _searchController.text = widget.filters.search ?? '';
      _lastSearchText = widget.filters.search ?? ''; // 同步更新上次搜索文本
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: colorScheme.outline.withValues(alpha: 0.2),
          width: 0.5,
        ),
      ),
      child: Column(
        children: [
          // 搜索栏和过滤器切换按钮
          Padding(
            padding: const EdgeInsets.all(12),
            child: Row(
              children: [
                Expanded(child: _buildSearchField(colorScheme)),
                const SizedBox(width: 12),
                _buildFilterToggleButton(colorScheme),
                if (widget.filters.hasFilters) ...[
                  const SizedBox(width: 8),
                  _buildClearFiltersButton(colorScheme),
                ],
              ],
            ),
          ),

          // 展开的过滤器选项
          AnimatedBuilder(
            animation: _expandAnimation,
            builder: (context, child) {
              return ClipRect(
                child: Align(
                  alignment: Alignment.topCenter,
                  heightFactor: _expandAnimation.value,
                  child: child,
                ),
              );
            },
            child: _buildExpandedFilters(colorScheme),
          ),
        ],
      ),
    );
  }

  /// 构建搜索输入框
  Widget _buildSearchField(ColorScheme colorScheme) {
    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLowest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        children: [
          Padding(
            padding: const EdgeInsets.only(left: 16, right: 8),
            child: Icon(
              CupertinoIcons.search,
              size: 16,
              color: colorScheme.onSurface.withValues(alpha: 0.5),
            ),
          ),
          Expanded(
            child: CupertinoTextField(
              controller: _searchController,
              placeholder: '搜索邮件主题、发件人...',
              placeholderStyle: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
                color: colorScheme.onSurface.withValues(alpha: 0.5),
                fontSize: 14,
              ),
              style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
                fontSize: 14,
                color: colorScheme.onSurface,
              ),
              decoration: const BoxDecoration(),
              padding: const EdgeInsets.symmetric(vertical: 10),
              textInputAction: TextInputAction.search,
              onChanged: (value) => _onSearchChanged(value, _searchController.value),
              onSubmitted: _onSearchSubmitted,
              onEditingComplete: _onEditingComplete,
            ),
          ),
          if (_searchController.text.isNotEmpty)
            GestureDetector(
              onTap: _clearSearch,
              child: Padding(
                padding: const EdgeInsets.only(right: 16, left: 8),
                child: Icon(
                  CupertinoIcons.xmark_circle_fill,
                  size: 16,
                  color: colorScheme.onSurface.withValues(alpha: 0.5),
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// 构建过滤器切换按钮
  Widget _buildFilterToggleButton(ColorScheme colorScheme) {
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact();
        setState(() {
          _isExpanded = !_isExpanded;
          if (_isExpanded) {
            _animationController.forward();
          } else {
            _animationController.reverse();
          }
        });
      },
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: _isExpanded || widget.filters.hasFilters
              ? colorScheme.primary.withValues(alpha: 0.1)
              : colorScheme.surfaceContainerLowest,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: _isExpanded || widget.filters.hasFilters
                ? colorScheme.primary.withValues(alpha: 0.3)
                : colorScheme.outline.withValues(alpha: 0.2),
            width: 0.5,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              CupertinoIcons.slider_horizontal_3,
              size: 16,
              color: _isExpanded || widget.filters.hasFilters
                  ? colorScheme.primary
                  : colorScheme.onSurface.withValues(alpha: 0.6),
            ),
            if (widget.filters.activeFiltersCount > 0) ...[
              const SizedBox(width: 4),
              Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  color: colorScheme.primary,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  '${widget.filters.activeFiltersCount}',
                  style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
                    fontSize: 10,
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onPrimary,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  /// 构建清除过滤器按钮
  Widget _buildClearFiltersButton(ColorScheme colorScheme) {
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact();
        widget.onClearFilters();
      },
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: colorScheme.error.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: colorScheme.error.withValues(alpha: 0.3),
            width: 0.5,
          ),
        ),
        child: Icon(
          CupertinoIcons.clear,
          size: 18,
          color: colorScheme.error,
        ),
      ),
    );
  }

  /// 构建展开的过滤器选项
  Widget _buildExpandedFilters(ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Divider(height: 1),
          const SizedBox(height: 16),
          
          // 邮件分类过滤
          _buildFilterSection(
            '邮件分类',
            [
              _buildFilterChip('全部', null, widget.filters.category, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(clearCategory: true));
              }, colorScheme),
              _buildFilterChip('验证邮件', 'verification', widget.filters.category, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(category: value));
              }, colorScheme),
              _buildFilterChip('发票邮件', 'invoice', widget.filters.category, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(category: value));
              }, colorScheme),
              _buildFilterChip('其他', 'other', widget.filters.category, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(category: value));
              }, colorScheme),
            ],
            colorScheme,
          ),

          const SizedBox(height: 16),

          // 处理状态过滤
          _buildFilterSection(
            '处理状态',
            [
              _buildFilterChip('全部', null, widget.filters.status, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(clearStatus: true));
              }, colorScheme),
              _buildFilterChip('成功', 'success', widget.filters.status, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(status: value));
              }, colorScheme),
              _buildFilterChip('部分成功', 'partial_success', widget.filters.status, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(status: value));
              }, colorScheme),
              _buildFilterChip('失败', 'failed', widget.filters.status, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(status: value));
              }, colorScheme),
              _buildFilterChip('未处理', 'not_processed', widget.filters.status, (value) {
                widget.onFiltersChanged(widget.filters.copyWith(status: value));
              }, colorScheme),
            ],
            colorScheme,
          ),

          const SizedBox(height: 16),

          // 日期范围过滤
          _buildDateRangeFilter(colorScheme),
        ],
      ),
    );
  }

  /// 构建过滤器分组
  Widget _buildFilterSection(
    String title,
    List<Widget> chips,
    ColorScheme colorScheme,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: chips,
        ),
      ],
    );
  }

  /// 构建过滤器标签
  Widget _buildFilterChip(
    String label,
    String? value,
    String? currentValue,
    Function(String?) onSelected,
    ColorScheme colorScheme,
  ) {
    final isSelected = currentValue == value;

    return GestureDetector(
      onTap: () {
        HapticFeedback.selectionClick();
        onSelected(value);
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected
              ? colorScheme.primary.withValues(alpha: 0.1)
              : colorScheme.surfaceContainerLowest,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected
                ? colorScheme.primary.withValues(alpha: 0.5)
                : colorScheme.outline.withValues(alpha: 0.3),
            width: isSelected ? 1 : 0.5,
          ),
        ),
        child: Text(
          label,
          style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
            fontSize: 13,
            fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
            color: isSelected
                ? colorScheme.primary
                : colorScheme.onSurface.withValues(alpha: 0.7),
          ),
        ),
      ),
    );
  }

  /// 构建日期范围过滤器
  Widget _buildDateRangeFilter(ColorScheme colorScheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '日期范围',
          style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: _buildDateSelector(
                '开始日期',
                widget.filters.dateFrom,
                (date) {
                  widget.onFiltersChanged(widget.filters.copyWith(dateFrom: date));
                },
                colorScheme,
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: _buildDateSelector(
                '结束日期',
                widget.filters.dateTo,
                (date) {
                  widget.onFiltersChanged(widget.filters.copyWith(dateTo: date));
                },
                colorScheme,
              ),
            ),
          ],
        ),
      ],
    );
  }

  /// 构建日期选择器
  Widget _buildDateSelector(
    String label,
    DateTime? selectedDate,
    Function(DateTime?) onDateSelected,
    ColorScheme colorScheme,
  ) {
    return GestureDetector(
      onTap: () async {
        HapticFeedback.lightImpact();
        final date = await showDatePicker(
          context: context,
          initialDate: selectedDate ?? DateTime.now(),
          firstDate: DateTime.now().subtract(const Duration(days: 365)),
          lastDate: DateTime.now(),
        );
        if (date != null) {
          onDateSelected(date);
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerLowest,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: colorScheme.outline.withValues(alpha: 0.3),
            width: 0.5,
          ),
        ),
        child: Row(
          children: [
            Icon(
              CupertinoIcons.calendar,
              size: 16,
              color: colorScheme.onSurface.withValues(alpha: 0.6),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                selectedDate != null
                    ? '${selectedDate.month}/${selectedDate.day}'
                    : label,
                style: CupertinoTheme.of(context).textTheme.textStyle.copyWith(
                  fontSize: 13,
                  color: selectedDate != null
                      ? colorScheme.onSurface
                      : colorScheme.onSurface.withValues(alpha: 0.5),
                ),
              ),
            ),
            if (selectedDate != null)
              GestureDetector(
                onTap: () {
                  HapticFeedback.lightImpact();
                  onDateSelected(null);
                },
                child: Icon(
                  CupertinoIcons.xmark_circle_fill,
                  size: 16,
                  color: colorScheme.onSurface.withValues(alpha: 0.5),
                ),
              ),
          ],
        ),
      ),
    );
  }

  /// 搜索控制器变化监听（仅用于UI状态更新）
  void _onSearchControllerChanged() {
    // 每次文本变化都更新UI，以便清除按钮能正确显示/隐藏
    setState(() {});
  }

  /// 搜索输入变化（防抖处理，支持中文输入法）
  void _onSearchChanged(String value, TextEditingValue textValue) {
    final wasComposing = _isComposing;
    _isComposing = textValue.composing.isValid;
    
    // 智能空内容检测：如果内容为空且上次搜索也为空，跳过搜索
    if (_shouldSkipEmptySearch(value)) {
      _debounceTimer?.cancel();
      _lastSearchText = value;
      return;
    }
    
    // 检测中文输入完成：从编辑状态变为非编辑状态，且文本有变化
    if (wasComposing && !_isComposing && value != _lastSearchText) {
      // 中文输入刚完成，立即搜索
      _debounceTimer?.cancel();
      _updateSearchWithValidation(value);
      _lastSearchText = value;
      return;
    }
    
    // 如果正在使用输入法编辑（如中文拼音输入中），暂停搜索
    if (_isComposing) {
      // 正在输入拼音，取消之前的定时器但不设置新的
      _debounceTimer?.cancel();
      return;
    }
    
    // 非中文输入状态或输入法未激活，使用正常防抖
    _debounceTimer?.cancel();
    _debounceTimer = Timer(const Duration(milliseconds: 600), () {
      if (!_isComposing) { // 双重检查确保不在输入状态
        _updateSearchWithValidation(value);
        _lastSearchText = value;
      }
    });
  }

  /// 搜索提交（立即执行）
  void _onSearchSubmitted(String value) {
    // 取消防抖定时器，立即执行搜索
    _debounceTimer?.cancel();
    _isComposing = false; // 提交时清除编辑状态
    _updateSearchWithValidation(value);
    _lastSearchText = value;
  }

  /// 编辑完成（中文输入法完成输入）
  void _onEditingComplete() {
    // 中文输入法完成输入，立即执行搜索
    _isComposing = false;
    _debounceTimer?.cancel();
    final value = _searchController.text;
    _updateSearchWithValidation(value);
    _lastSearchText = value;
  }

  /// 清除搜索
  void _clearSearch() {
    // 取消防抖定时器
    _debounceTimer?.cancel();
    _isComposing = false;
    // 清空搜索框
    _searchController.clear();
    // 立即更新搜索
    _updateSearch('');
    _lastSearchText = '';
    // 更新UI状态
    setState(() {});
  }

  /// 智能检测是否应该跳过空搜索
  bool _shouldSkipEmptySearch(String currentValue) {
    final trimmedValue = currentValue.trim();
    final trimmedLastSearch = _lastSearchText.trim();
    
    // 如果当前值为空且上次搜索也为空，跳过搜索
    if (trimmedValue.isEmpty && trimmedLastSearch.isEmpty) {
      return true;
    }
    
    // 如果当前值和上次搜索完全相同，跳过搜索
    if (trimmedValue == trimmedLastSearch) {
      return true;
    }
    
    return false;
  }

  /// 带验证的搜索更新（智能跳过无意义的搜索）
  void _updateSearchWithValidation(String value) {
    final trimmedValue = value.trim();
    
    // 如果是有意义的搜索（非空或从非空变为空），才执行搜索
    if (trimmedValue.isNotEmpty || _lastSearchText.trim().isNotEmpty) {
      _updateSearch(value);
    }
  }

  /// 更新搜索内容（实际的搜索逻辑）
  void _updateSearch(String value) {
    widget.onFiltersChanged(widget.filters.copyWith(search: value.isEmpty ? null : value));
  }
}